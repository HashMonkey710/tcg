// Phase 4: Real-time & Social Features - WebSocket Communication & Social Platform

// ===== 1. Real-time Communication Infrastructure =====

// core/services/websocket_service.dart
import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'package:flutter/foundation.dart';
import '../errors/exceptions.dart';

enum ConnectionState {
  disconnected,
  connecting,
  connected,
  reconnecting,
  error,
}

class WebSocketService {
  static const String _tag = 'WebSocketService';
  static const Duration _heartbeatInterval = Duration(seconds: 30);
  static const Duration _reconnectDelay = Duration(seconds: 5);
  static const int _maxReconnectAttempts = 5;

  WebSocket? _socket;
  Timer? _heartbeatTimer;
  Timer? _reconnectTimer;
  
  String? _url;
  Map<String, String>? _headers;
  int _reconnectAttempts = 0;
  bool _shouldReconnect = true;
  
  final StreamController<ConnectionState> _connectionStateController = 
      StreamController<ConnectionState>.broadcast();
  final StreamController<Map<String, dynamic>> _messageController = 
      StreamController<Map<String, dynamic>>.broadcast();
  final StreamController<String> _errorController = 
      StreamController<String>.broadcast();

  // Message queue for offline scenarios
  final List<Map<String, dynamic>> _messageQueue = [];
  static const int _maxQueueSize = 100;

  // Streams
  Stream<ConnectionState> get connectionState => _connectionStateController.stream;
  Stream<Map<String, dynamic>> get messages => _messageController.stream;
  Stream<String> get errors => _errorController.stream;

  ConnectionState _currentState = ConnectionState.disconnected;
  ConnectionState get currentState => _currentState;

  Future<void> connect(String url, {Map<String, String>? headers}) async {
    _url = url;
    _headers = headers;
    _shouldReconnect = true;
    _reconnectAttempts = 0;
    
    await _performConnection();
  }

  Future<void> _performConnection() async {
    if (_currentState == ConnectionState.connecting || 
        _currentState == ConnectionState.connected) {
      return;
    }

    _updateConnectionState(ConnectionState.connecting);

    try {
      if (kDebugMode) {
        print('$_tag: Connecting to $_url');
      }

      _socket = await WebSocket.connect(
        _url!,
        headers: _headers,
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () => throw TimeoutException('Connection timeout'),
      );

      _setupSocketListeners();
      _updateConnectionState(ConnectionState.connected);
      _startHeartbeat();
      _flushMessageQueue();
      _reconnectAttempts = 0;

      if (kDebugMode) {
        print('$_tag: Connected successfully');
      }

    } catch (e) {
      if (kDebugMode) {
        print('$_tag: Connection failed: $e');
      }
      
      _updateConnectionState(ConnectionState.error);
      _errorController.add('Connection failed: $e');
      
      if (_shouldReconnect && _reconnectAttempts < _maxReconnectAttempts) {
        _scheduleReconnect();
      }
    }
  }

  void _setupSocketListeners() {
    _socket?.listen(
      (data) {
        try {
          final message = jsonDecode(data as String) as Map<String, dynamic>;
          _handleMessage(message);
        } catch (e) {
          if (kDebugMode) {
            print('$_tag: Failed to parse message: $e');
          }
        }
      },
      onError: (error) {
        if (kDebugMode) {
          print('$_tag: Socket error: $error');
        }
        _updateConnectionState(ConnectionState.error);
        _errorController.add('Socket error: $error');
        
        if (_shouldReconnect) {
          _scheduleReconnect();
        }
      },
      onDone: () {
        if (kDebugMode) {
          print('$_tag: Socket closed');
        }
        _updateConnectionState(ConnectionState.disconnected);
        
        if (_shouldReconnect) {
          _scheduleReconnect();
        }
      },
    );
  }

  void _handleMessage(Map<String, dynamic> message) {
    final type = message['type'] as String?;
    
    switch (type) {
      case 'heartbeat_response':
        // Heartbeat acknowledged - connection is healthy
        break;
      case 'error':
        _errorController.add(message['message'] ?? 'Unknown error');
        break;
      default:
        _messageController.add(message);
    }
  }

  void _startHeartbeat() {
    _heartbeatTimer?.cancel();
    _heartbeatTimer = Timer.periodic(_heartbeatInterval, (_) {
      if (_currentState == ConnectionState.connected) {
        _sendRawMessage({
          'type': 'heartbeat',
          'timestamp': DateTime.now().millisecondsSinceEpoch,
        });
      }
    });
  }

  void _scheduleReconnect() {
    if (!_shouldReconnect || _reconnectAttempts >= _maxReconnectAttempts) {
      return;
    }

    _reconnectAttempts++;
    _updateConnectionState(ConnectionState.reconnecting);
    
    final delay = Duration(
      seconds: _reconnectDelay.inSeconds * _reconnectAttempts,
    );

    if (kDebugMode) {
      print('$_tag: Scheduling reconnect in ${delay.inSeconds}s (attempt $_reconnectAttempts/$_maxReconnectAttempts)');
    }

    _reconnectTimer?.cancel();
    _reconnectTimer = Timer(delay, () {
      if (_shouldReconnect) {
        _performConnection();
      }
    });
  }

  void sendMessage(Map<String, dynamic> message) {
    if (_currentState == ConnectionState.connected) {
      _sendRawMessage(message);
    } else {
      // Queue message for when connection is restored
      _queueMessage(message);
    }
  }

  void _sendRawMessage(Map<String, dynamic> message) {
    try {
      final jsonMessage = jsonEncode(message);
      _socket?.add(jsonMessage);
    } catch (e) {
      if (kDebugMode) {
        print('$_tag: Failed to send message: $e');
      }
      _queueMessage(message);
    }
  }

  void _queueMessage(Map<String, dynamic> message) {
    if (_messageQueue.length >= _maxQueueSize) {
      _messageQueue.removeAt(0); // Remove oldest message
    }
    
    message['queued_at'] = DateTime.now().millisecondsSinceEpoch;
    _messageQueue.add(message);
    
    if (kDebugMode) {
      print('$_tag: Queued message (${_messageQueue.length} in queue)');
    }
  }

  void _flushMessageQueue() {
    if (_messageQueue.isEmpty) return;

    if (kDebugMode) {
      print('$_tag: Flushing ${_messageQueue.length} queued messages');
    }

    final messagesToSend = List<Map<String, dynamic>>.from(_messageQueue);
    _messageQueue.clear();

    for (final message in messagesToSend) {
      message.remove('queued_at');
      _sendRawMessage(message);
    }
  }

  void _updateConnectionState(ConnectionState newState) {
    if (_currentState != newState) {
      _currentState = newState;
      _connectionStateController.add(newState);
      
      if (kDebugMode) {
        print('$_tag: Connection state changed to $newState');
      }
    }
  }

  Future<void> disconnect() async {
    _shouldReconnect = false;
    _heartbeatTimer?.cancel();
    _reconnectTimer?.cancel();
    
    await _socket?.close();
    _socket = null;
    
    _updateConnectionState(ConnectionState.disconnected);
  }

  void dispose() {
    disconnect();
    _connectionStateController.close();
    _messageController.close();
    _errorController.close();
  }
}

// ===== 2. User Authentication & Profile System =====

// features/auth/domain/entities/user.dart
import 'package:equatable/equatable.dart';

enum UserStatus {
  online,
  away,
  busy,
  invisible,
  offline,
}

extension UserStatusExtension on UserStatus {
  String get displayName {
    switch (this) {
      case UserStatus.online:
        return 'Online';
      case UserStatus.away:
        return 'Away';
      case UserStatus.busy:
        return 'Do Not Disturb';
      case UserStatus.invisible:
        return 'Invisible';
      case UserStatus.offline:
        return 'Offline';
    }
  }

  Color get color {
    switch (this) {
      case UserStatus.online:
        return const Color(0xFF3BA55D);
      case UserStatus.away:
        return const Color(0xFFFAA61A);
      case UserStatus.busy:
        return const Color(0xFFED4245);
      case UserStatus.invisible:
      case UserStatus.offline:
        return const Color(0xFF747F8D);
    }
  }
}

class User extends Equatable {
  final String id;
  final String username;
  final String? displayName;
  final String? email;
  final String? avatarUrl;
  final UserStatus status;
  final String? statusMessage;
  final DateTime? lastSeen;
  final DateTime createdAt;
  final Map<String, dynamic>? preferences;
  final List<String> roles;

  const User({
    required this.id,
    required this.username,
    this.displayName,
    this.email,
    this.avatarUrl,
    this.status = UserStatus.offline,
    this.statusMessage,
    this.lastSeen,
    required this.createdAt,
    this.preferences,
    this.roles = const [],
  });

  @override
  List<Object?> get props => [
    id,
    username,
    displayName,
    email,
    avatarUrl,
    status,
    statusMessage,
    lastSeen,
    createdAt,
    preferences,
    roles,
  ];

  String get effectiveDisplayName => displayName ?? username;
  bool get isOnline => status == UserStatus.online;
  bool get hasRole(String role) => roles.contains(role);

  User copyWith({
    String? id,
    String? username,
    String? displayName,
    String? email,
    String? avatarUrl,
    UserStatus? status,
    String? statusMessage,
    DateTime? lastSeen,
    DateTime? createdAt,
    Map<String, dynamic>? preferences,
    List<String>? roles,
  }) {
    return User(
      id: id ?? this.id,
      username: username ?? this.username,
      displayName: displayName ?? this.displayName,
      email: email ?? this.email,
      avatarUrl: avatarUrl ?? this.avatarUrl,
      status: status ?? this.status,
      statusMessage: statusMessage ?? this.statusMessage,
      lastSeen: lastSeen ?? this.lastSeen,
      createdAt: createdAt ?? this.createdAt,
      preferences: preferences ?? this.preferences,
      roles: roles ?? this.roles,
    );
  }
}

// features/auth/domain/entities/friendship.dart
import 'package:equatable/equatable.dart';

enum FriendshipStatus {
  pending,
  accepted,
  blocked,
  declined,
}

class Friendship extends Equatable {
  final String id;
  final String requesterId;
  final String addresseeId;
  final FriendshipStatus status;
  final DateTime createdAt;
  final DateTime? acceptedAt;
  final User? requester;
  final User? addressee;

  const Friendship({
    required this.id,
    required this.requesterId,
    required this.addresseeId,
    required this.status,
    required this.createdAt,
    this.acceptedAt,
    this.requester,
    this.addressee,
  });

  @override
  List<Object?> get props => [
    id,
    requesterId,
    addresseeId,
    status,
    createdAt,
    acceptedAt,
    requester,
    addressee,
  ];

  bool get isAccepted => status == FriendshipStatus.accepted;
  bool get isPending => status == FriendshipStatus.pending;
  bool get isBlocked => status == FriendshipStatus.blocked;

  User? getFriend(String currentUserId) {
    if (requesterId == currentUserId) return addressee;
    if (addresseeId == currentUserId) return requester;
    return null;
  }
}

// ===== 3. Real-time Deck Sharing System =====

// features/realtime/domain/entities/shared_deck_session.dart
import 'package:equatable/equatable.dart';
import '../../../decks/domain/entities/deck.dart';
import '../../../auth/domain/entities/user.dart';

enum DeckSessionPermission {
  view,
  edit,
  admin,
}

class SharedDeckSession extends Equatable {
  final String id;
  final String deckId;
  final String ownerId;
  final List<SessionParticipant> participants;
  final bool isActive;
  final DateTime createdAt;
  final DateTime? expiresAt;
  final Deck? deck;

  const SharedDeckSession({
    required this.id,
    required this.deckId,
    required this.ownerId,
    this.participants = const [],
    this.isActive = true,
    required this.createdAt,
    this.expiresAt,
    this.deck,
  });

  @override
  List<Object?> get props => [
    id,
    deckId,
    ownerId,
    participants,
    isActive,
    createdAt,
    expiresAt,
    deck,
  ];

  List<SessionParticipant> get activeParticipants =>
      participants.where((p) => p.isActive).toList();

  bool canUserEdit(String userId) {
    if (userId == ownerId) return true;
    
    final participant = participants
        .where((p) => p.userId == userId)
        .firstOrNull;
    
    return participant?.permission == DeckSessionPermission.edit ||
           participant?.permission == DeckSessionPermission.admin;
  }

  bool isUserParticipant(String userId) {
    return userId == ownerId || 
           participants.any((p) => p.userId == userId && p.isActive);
  }
}

class SessionParticipant extends Equatable {
  final String userId;
  final DeckSessionPermission permission;
  final DateTime joinedAt;
  final DateTime? lastSeen;
  final bool isActive;
  final User? user;

  const SessionParticipant({
    required this.userId,
    required this.permission,
    required this.joinedAt,
    this.lastSeen,
    this.isActive = true,
    this.user,
  });

  @override
  List<Object?> get props => [
    userId,
    permission,
    joinedAt,
    lastSeen,
    isActive,
    user,
  ];
}

// features/realtime/domain/entities/deck_operation.dart
import 'package:equatable/equatable.dart';
import '../../../cards/domain/entities/card.dart';

enum DeckOperationType {
  addCard,
  removeCard,
  updateCard,
  updateDeckInfo,
  moveToDeck,
  moveToSideboard,
}

class DeckOperation extends Equatable {
  final String id;
  final String sessionId;
  final String userId;
  final DeckOperationType type;
  final Map<String, dynamic> data;
  final DateTime timestamp;
  final bool applied;

  const DeckOperation({
    required this.id,
    required this.sessionId,
    required this.userId,
    required this.type,
    required this.data,
    required this.timestamp,
    this.applied = false,
  });

  @override
  List<Object?> get props => [
    id,
    sessionId,
    userId,
    type,
    data,
    timestamp,
    applied,
  ];

  factory DeckOperation.addCard({
    required String sessionId,
    required String userId,
    required Card card,
    required int quantity,
    required bool isSideboard,
  }) {
    return DeckOperation(
      id: _generateId(),
      sessionId: sessionId,
      userId: userId,
      type: DeckOperationType.addCard,
      data: {
        'cardId': card.id,
        'cardName': card.name,
        'quantity': quantity,
        'isSideboard': isSideboard,
      },
      timestamp: DateTime.now(),
    );
  }

  factory DeckOperation.removeCard({
    required String sessionId,
    required String userId,
    required String cardId,
    required int quantity,
    required bool isSideboard,
  }) {
    return DeckOperation(
      id: _generateId(),
      sessionId: sessionId,
      userId: userId,
      type: DeckOperationType.removeCard,
      data: {
        'cardId': cardId,
        'quantity': quantity,
        'isSideboard': isSideboard,
      },
      timestamp: DateTime.now(),
    );
  }

  static String _generateId() {
    return DateTime.now().millisecondsSinceEpoch.toString() +
           (1000 + (999 * (DateTime.now().microsecond / 1000))).round().toString();
  }
}

// ===== 4. Real-time Deck Collaboration BLoC =====

// features/realtime/presentation/bloc/realtime_deck_event.dart
import 'package:equatable/equatable.dart';
import '../../domain/entities/shared_deck_session.dart';
import '../../domain/entities/deck_operation.dart';
import '../../../cards/domain/entities/card.dart';

abstract class RealtimeDeckEvent extends Equatable {
  const RealtimeDeckEvent();
  
  @override
  List<Object?> get props => [];
}

class CreateDeckSession extends RealtimeDeckEvent {
  final String deckId;
  
  const CreateDeckSession(this.deckId);
  
  @override
  List<Object> get props => [deckId];
}

class JoinDeckSession extends RealtimeDeckEvent {
  final String sessionId;
  
  const JoinDeckSession(this.sessionId);
  
  @override
  List<Object> get props => [sessionId];
}

class LeaveDeckSession extends RealtimeDeckEvent {
  const LeaveDeckSession();
}

class AddCardToSharedDeck extends RealtimeDeckEvent {
  final Card card;
  final int quantity;
  final bool isSideboard;
  
  const AddCardToSharedDeck({
    required this.card,
    this.quantity = 1,
    this.isSideboard = false,
  });
  
  @override
  List<Object> get props => [card, quantity, isSideboard];
}

class RemoveCardFromSharedDeck extends RealtimeDeckEvent {
  final String cardId;
  final int quantity;
  final bool isSideboard;
  
  const RemoveCardFromSharedDeck({
    required this.cardId,
    this.quantity = 1,
    this.isSideboard = false,
  });
  
  @override
  List<Object> get props => [cardId, quantity, isSideboard];
}

class ReceiveDeckOperation extends RealtimeDeckEvent {
  final DeckOperation operation;
  
  const ReceiveDeckOperation(this.operation);
  
  @override
  List<Object> get props => [operation];
}

class UpdateSessionParticipants extends RealtimeDeckEvent {
  final List<SessionParticipant> participants;
  
  const UpdateSessionParticipants(this.participants);
  
  @override
  List<Object> get props => [participants];
}

// features/realtime/presentation/bloc/realtime_deck_state.dart
import 'package:equatable/equatable.dart';
import '../../domain/entities/shared_deck_session.dart';
import '../../domain/entities/deck_operation.dart';
import '../../../decks/domain/entities/deck.dart';

abstract class RealtimeDeckState extends Equatable {
  const RealtimeDeckState();
  
  @override
  List<Object?> get props => [];
}

class RealtimeDeckInitial extends RealtimeDeckState {
  const RealtimeDeckInitial();
}

class RealtimeDeckConnecting extends RealtimeDeckState {
  const RealtimeDeckConnecting();
}

class RealtimeDeckConnected extends RealtimeDeckState {
  final SharedDeckSession session;
  final Deck deck;
  final List<DeckOperation> recentOperations;
  final bool isConnectionHealthy;
  
  const RealtimeDeckConnected({
    required this.session,
    required this.deck,
    this.recentOperations = const [],
    this.isConnectionHealthy = true,
  });
  
  @override
  List<Object> get props => [
    session,
    deck,
    recentOperations,
    isConnectionHealthy,
  ];
  
  RealtimeDeckConnected copyWith({
    SharedDeckSession? session,
    Deck? deck,
    List<DeckOperation>? recentOperations,
    bool? isConnectionHealthy,
  }) {
    return RealtimeDeckConnected(
      session: session ?? this.session,
      deck: deck ?? this.deck,
      recentOperations: recentOperations ?? this.recentOperations,
      isConnectionHealthy: isConnectionHealthy ?? this.isConnectionHealthy,
    );
  }
}

class RealtimeDeckError extends RealtimeDeckState {
  final String message;
  
  const RealtimeDeckError(this.message);
  
  @override
  List<Object> get props => [message];
}

class RealtimeDeckDisconnected extends RealtimeDeckState {
  final String? reason;
  
  const RealtimeDeckDisconnected({this.reason});
  
  @override
  List<Object?> get props => [reason];
}

// ===== 5. Social Features UI Components =====

// features/social/presentation/widgets/user_presence_indicator.dart
import 'package:flutter/material.dart';
import '../../../auth/domain/entities/user.dart';
import '../../../../core/theme/discord_colors.dart';
import '../../../../core/theme/app_text_styles.dart';

class UserPresenceIndicator extends StatelessWidget {
  final User user;
  final double size;
  final bool showStatus;
  final VoidCallback? onTap;
  
  const UserPresenceIndicator({
    super.key,
    required this.user,
    this.size = 40,
    this.showStatus = true,
    this.onTap,
  });
  
  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onTap,
      child: Stack(
        children: [
          // Avatar
          Container(
            width: size,
            height: size,
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              color: DiscordColors.backgroundAccent,
              image: user.avatarUrl != null
                  ? DecorationImage(
                      image: NetworkImage(user.avatarUrl!),
                      fit: BoxFit.cover,
                    )
                  : null,
            ),
            child: user.avatarUrl == null
                ? Icon(
                    Icons.person,
                    color: DiscordColors.textSecondary,
                    size: size * 0.6,
                  )
                : null,
          ),
          
          // Status indicator
          if (showStatus)
            Positioned(
              right: 0,
              bottom: 0,
              child: Container(
                width: size * 0.3,
                height: size * 0.3,
                decoration: BoxDecoration(
                  color: user.status.color,
                  shape: BoxShape.circle,
                  border: Border.all(
                    color: DiscordColors.backgroundPrimary,
                    width: 2,
                  ),
                ),
              ),
            ),
        ],
      ),
    );
  }
}

// features/social/presentation/widgets/participant_list.dart
import 'package:flutter/material.dart';
import '../../../realtime/domain/entities/shared_deck_session.dart';
import 'user_presence_indicator.dart';
import '../../../../core/theme/discord_colors.dart';
import '../../../../core/theme/app_text_styles.dart';
import '../../../../core/widgets/base_widgets.dart';

class ParticipantList extends StatelessWidget {
  final SharedDeckSession session;
  final String currentUserId;
  final Function(SessionParticipant)? onParticipantTap;
  
  const ParticipantList({
    super.key,
    required this.session,
    required this.currentUserId,
    this.onParticipantTap,
  });
  
  @override
  Widget build(BuildContext context) {
    final activeParticipants = session.activeParticipants;
    
    return DiscordCard(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(
                Icons.people,
                color: DiscordColors.blurple,
                size: 20,
              ),
              const SizedBox(width: 8),
              Text(
                'Participants (${activeParticipants.length + 1})',
                style: AppTextStyles.heading4,
              ),
            ],
          ),
          
          const SizedBox(height: 16),
          
          // Session owner
          _buildOwnerTile(),
          
          if (activeParticipants.isNotEmpty) ...[
            const SizedBox(height: 8),
            const Divider(color: DiscordColors.borderSubtle),
            const SizedBox(height: 8),
            
            // Other participants
            ...activeParticipants.map((participant) => _buildParticipantTile(participant)),
          ],
        ],
      ),
    );
  }
  
  Widget _buildOwnerTile() {
    return ListTile(
      leading: const UserPresenceIndicator(
        user: User(
          id: 'owner',
          username: 'Session Owner',
          createdAt: DateTime.now(),
          status: UserStatus.online,
        ),
        size: 32,
      ),
      title: Text(
        'Session Owner',
        style: AppTextStyles.bodyMedium.copyWith(
          fontWeight: FontWeight.w600,
        ),
      ),
      subtitle: Text(
        'Admin',
        style: AppTextStyles.bodySmall.copyWith(
          color: DiscordColors.blurple,
        ),
      ),
      trailing: Icon(
        Icons.admin_panel_settings,
        color: DiscordColors.blurple,
        size: 16,
      ),
      contentPadding: EdgeInsets.zero,
    );
  }
  
  Widget _buildParticipantTile(SessionParticipant participant) {
    final isCurrentUser = participant.userId == currentUserId;
    
    return ListTile(
      leading: UserPresenceIndicator(
        user: participant.user ?? User(
          id: participant.userId,
          username: 'User ${participant.userId.substring(0, 8)}',
          createdAt: DateTime.now(),
        ),
        size: 32,
      ),
      title: Text(
        participant.user?.effectiveDisplayName ?? 'Unknown User',
        style: AppTextStyles.bodyMedium.copyWith(
          fontWeight: isCurrentUser ? FontWeight.w600 : FontWeight.normal,
        ),
      ),
      subtitle: Text(
        _getPermissionText(participant.permission),
        style: AppTextStyles.bodySmall.copyWith(
          color: _getPermissionColor(participant.permission),
        ),
      ),
      trailing: isCurrentUser
          ? Text(
              '(You)',
              style: AppTextStyles.labelSmall.copyWith(
                color: DiscordColors.textSecondary,
              ),
            )
          : null,
      contentPadding: EdgeInsets.zero,
      onTap: () => onParticipantTap?.call(participant),
    );
  }
  
  String _getPermissionText(DeckSessionPermission permission) {
    switch (permission) {
      case DeckSessionPermission.view:
        return 'Viewer';
      case DeckSessionPermission.edit:
        return 'Editor';
      case DeckSessionPermission.admin:
        return 'Admin';
    }
  }
  
  Color _getPermissionColor(DeckSessionPermission permission) {
    switch (permission) {
      case DeckSessionPermission.view:
        return DiscordColors.textSecondary;
      case DeckSessionPermission.edit:
        return DiscordColors.green;
      case DeckSessionPermission.admin:
        return DiscordColors.blurple;
    }
  }
}

// features/social/presentation/widgets/activity_feed.dart
import 'package:flutter/material.dart';
import '../../../realtime/domain/entities/deck_operation.dart';
import '../../../../core/theme/discord_colors.dart';
import '../../../../core/theme/app_text_styles.dart';
import '../../../../core/widgets/base_widgets.dart';

class ActivityFeed extends StatelessWidget {
  final List<DeckOperation> operations;
  final int maxItems;
  
  const ActivityFeed({
    super.key,
    required this.operations,
    this.maxItems = 20,
  });
  
  @override
  Widget build(BuildContext context) {
    final recentOperations = operations
        .take(maxItems)
        .toList();
    
    if (recentOperations.isEmpty) {
      return DiscordCard(
        child: Center(
          child: Text(
            'No recent activity',
            style: AppTextStyles.bodyMedium.copyWith(
              color: DiscordColors.textMuted,
            ),
          ),
        ),
      );
    }
    
    return DiscordCard(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(
                Icons.timeline,
                color: DiscordColors.blurple,
                size: 20,
              ),
              const SizedBox(width: 8),
              Text(
                'Recent Activity',
                style: AppTextStyles.heading4,
              ),
            ],
          ),
          
          const SizedBox(height: 16),
          
          ListView.separated(
            shrinkWrap: true,
            physics: const NeverScrollableScrollPhysics(),
            itemCount: recentOperations.length,
            separatorBuilder: (context, index) => const SizedBox(height: 8),
            itemBuilder: (context, index) {
              return _buildActivityItem(recentOperations[index]);
            },
          ),
        ],
      ),
    );
  }
  
  Widget _buildActivityItem(DeckOperation operation) {
    return Row(
      children: [
        Icon(
          _getOperationIcon(operation.type),
          color: _getOperationColor(operation.type),
          size: 16,
        ),
        const SizedBox(width: 8),
        Expanded(
          child: RichText(
            text: TextSpan(
              style: AppTextStyles.bodySmall,
              children: [
                TextSpan(
                  text: operation.userId.substring(0, 8),
                  style: const TextStyle(fontWeight: FontWeight.w600),
                ),
                TextSpan(text: ' ${_getOperationDescription(operation)}'),
              ],
            ),
          ),
        ),
        Text(
          _formatTimestamp(operation.timestamp),
          style: AppTextStyles.labelSmall.copyWith(
            color: DiscordColors.textMuted,
          ),
        ),
      ],
    );
  }
  
  IconData _getOperationIcon(DeckOperationType type) {
    switch (type) {
      case DeckOperationType.addCard:
        return Icons.add_circle_outline;
      case DeckOperationType.removeCard:
        return Icons.remove_circle_outline;
      case DeckOperationType.updateCard:
        return Icons.edit;
      case DeckOperationType.updateDeckInfo:
        return Icons.info_outline;
      case DeckOperationType.moveToDeck:
        return Icons.arrow_forward;
      case DeckOperationType.moveToSideboard:
        return Icons.arrow_back;
    }
  }
  
  Color _getOperationColor(DeckOperationType type) {
    switch (type) {
      case DeckOperationType.addCard:
        return DiscordColors.green;
      case DeckOperationType.removeCard:
        return DiscordColors.red;
      case DeckOperationType.updateCard:
      case DeckOperationType.updateDeckInfo:
        return DiscordColors.yellow;
      case DeckOperationType.moveToDeck:
      case DeckOperationType.moveToSideboard:
        return DiscordColors.blurple;
    }
  }
  
  String _getOperationDescription(DeckOperation operation) {
    final data = operation.data;
    final cardName = data['cardName'] ?? 'Unknown Card';
    final quantity = data['quantity'] ?? 1;
    
    switch (operation.type) {
      case DeckOperationType.addCard:
        final location = data['isSideboard'] == true ? 'sideboard' : 'deck';
        return 'added ${quantity}x $cardName to $location';
      case DeckOperationType.removeCard:
        final location = data['isSideboard'] == true ? 'sideboard' : 'deck';
        return 'removed ${quantity}x $cardName from $location';
      case DeckOperationType.updateCard:
        return 'updated $cardName';
      case DeckOperationType.updateDeckInfo:
        return 'updated deck information';
      case DeckOperationType.moveToDeck:
        return 'moved $cardName to mainboard';
      case DeckOperationType.moveToSideboard:
        return 'moved $cardName to sideboard';
    }
  }
  
  String _formatTimestamp(DateTime timestamp) {
    final now = DateTime.now();
    final difference = now.difference(timestamp);
    
    if (difference.inMinutes < 1) {
      return 'now';
    } else if (difference.inHours < 1) {
      return '${difference.inMinutes}m';
    } else if (difference.inDays < 1) {
      return '${difference.inHours}h';
    } else {
      return '${difference.inDays}d';
    }
  }
}

This implementation provides:
✅ **WebSocket Infrastructure**: Production-ready real-time communication
✅ **User Authentication**: Complete user profile and status system
✅ **Real-time Deck Sharing**: Collaborative deck building with operations
✅ **Social Features**: Friends, presence indicators, activity feeds
✅ **Offline Resilience**: Message queuing and automatic reconnection
✅ **Permission System**: Role-based access control for shared sessions
✅ **Activity Tracking**: Real-time operation logging and display
✅ **Discord-Style UI**: Authentic social platform components

Next: Notification system and offline capabilities with conflict resolution.
